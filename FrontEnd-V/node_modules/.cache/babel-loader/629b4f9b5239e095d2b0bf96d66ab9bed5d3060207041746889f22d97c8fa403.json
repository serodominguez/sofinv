{"ast":null,"code":"import axios from 'axios';\nconst state = {\n  brands: [],\n  selectedBrand: null,\n  loading: false,\n  error: null\n};\nconst mutations = {\n  SET_BRANDS(state, brands) {\n    state.brands = brands;\n  },\n  SET_SELECTED_BRAND(state, brand) {\n    state.selectedBrand = brand;\n  },\n  SET_LOADING(state, loading) {\n    state.loading = loading;\n  },\n  SET_ERROR(state, error) {\n    state.error = error;\n  }\n};\nconst isValid = token => {\n  const currentTime = Date.now() / 1000;\n  console.log(token.exp);\n  return token.exp < currentTime;\n};\nconst actions = {\n  async fetchBrands({\n    commit,\n    rootState\n  }) {\n    commit('SET_LOADING', true);\n    try {\n      const token = rootState.token;\n      console.log(rootState.token);\n      if (!isValid(rootState.token)) {\n        let header = {\n          Authorization: \"Bearer \" + token\n        };\n        let configuration = {\n          headers: header\n        };\n        const response = await axios.get('api/Brands/ReadBrands', configuration);\n        commit('SET_BRANDS', response.data);\n      }\n    } catch (error) {\n      commit('SET_ERROR', error.message);\n    } finally {\n      commit('SET_LOADING', false);\n    }\n  },\n  async fetchBrand({\n    commit,\n    rootState\n  }, text) {\n    commit('SET_LOADING', true);\n    try {\n      const token = rootState.token;\n      let header = {\n        Authorization: \"Bearer \" + token\n      };\n      let configuration = {\n        headers: header\n      };\n      const response = await axios.get(`api/Brands/SearchBrand/${text}`, configuration);\n      commit('SET_BRANDS', response.data);\n    } catch (error) {\n      commit('SET_ERROR', error.message);\n    } finally {\n      commit('SET_LOADING', false);\n    }\n  },\n  async selectBrands({\n    commit,\n    rootState\n  }) {\n    commit('SET_LOADING', true);\n    try {\n      const token = rootState.token;\n      let header = {\n        Authorization: \"Bearer \" + token\n      };\n      let configuration = {\n        headers: header\n      };\n      const response = await axios.get('api/Brands/SelectBrands', configuration);\n      commit('SET_BRANDS', response.data);\n    } catch (error) {\n      commit('SET_ERROR', error.message);\n    } finally {\n      commit('SET_LOADING', false);\n    }\n  },\n  async createBrand({\n    dispatch,\n    rootState\n  }, brand) {\n    const token = rootState.token;\n    let header = {\n      Authorization: \"Bearer \" + token\n    };\n    let configuration = {\n      headers: header\n    };\n    await axios.post('api/Brands/CreateBrand', brand, configuration);\n    dispatch('fetchBrands');\n  },\n  async updateBrand({\n    dispatch,\n    rootState\n  }, brand) {\n    const token = rootState.token;\n    let header = {\n      Authorization: \"Bearer \" + token\n    };\n    let configuration = {\n      headers: header\n    };\n    await axios.put('api/Brands/UpdateBrand', brand, configuration);\n    dispatch('fetchBrands');\n  },\n  async enabledBrand({\n    dispatch,\n    rootState\n  }, id) {\n    const token = rootState.token;\n    let header = {\n      Authorization: \"Bearer \" + token\n    };\n    let configuration = {\n      headers: header\n    };\n    await axios.put(`api/Brands/EnabledBrand/${id}`, {}, configuration);\n    dispatch('fetchBrands');\n  },\n  async disabledBrand({\n    dispatch,\n    rootState\n  }, id) {\n    const token = rootState.token;\n    let header = {\n      Authorization: \"Bearer \" + token\n    };\n    let configuration = {\n      headers: header\n    };\n    await axios.put(`api/Brands/DisabledBrand/${id}`, {}, configuration);\n    dispatch('fetchBrands');\n  }\n};\nconst getters = {\n  brands: state => state.brands,\n  selectedBrand: state => state.selectedBrand,\n  loading: state => state.loading,\n  error: state => state.error\n};\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions,\n  getters\n};\n\n/* State:\r\nbrands: Un array que contiene todas las marcas obtenidas de la API.\r\nselectedBrand: Un objeto que representa la marca actualmente seleccionada para edición.\r\nloading: Un booleano que indica si se está cargando información (por ejemplo, al hacer una solicitud a la API).\r\nerror: Un string que almacena cualquier mensaje de error que pueda ocurrir durante las operaciones.\r\n\r\nMutations:\r\nSET_BRANDS(state, brands): Actualiza el estado de brands con la lista de marcas obtenidas.\r\nSET_SELECTED_BRAND(state, brand): Establece la marca seleccionada en el estado.\r\nSET_LOADING(state, loading): Actualiza el estado de loading para indicar si se está realizando una operación de carga.\r\nSET_ERROR(state, error): Establece un mensaje de error en el estado.\r\n\r\nActions:\r\nfetchBrands({ commit }): Realiza una solicitud a la API para obtener todas las marcas. Utiliza commit para llamar a las mutaciones correspondientes para actualizar el estado.\r\ncreateBrand({ dispatch }, brand): Envía una solicitud a la API para crear una nueva marca y luego vuelve a obtener la lista de marcas.\r\nupdateBrand({ dispatch }, brand): Envía una solicitud a la API para actualizar una marca existente y luego vuelve a obtener la lista de marcas.\r\ndeleteBrand({ dispatch }, id): Envía una solicitud a la API para eliminar una marca y luego vuelve a obtener la lista de marcas.\r\n\r\nGetters:\r\nbrands: Devuelve la lista de marcas del estado.\r\nselectedBrand: Devuelve la marca seleccionada del estado.\r\nloading: Devuelve el estado de carga.\r\nerror: Devuelve cualquier mensaje de error.\r\n\r\nExport:\r\nnamespaced: true: Esto permite que el módulo sea utilizado de manera independiente, lo que significa que puedes acceder a sus propiedades y métodos utilizando el nombre del módulo (por ejemplo, store.modules.brand.fetchBrands).\r\nSe exporta el objeto que contiene state, mutations, actions y getters. */","map":{"version":3,"names":["axios","state","brands","selectedBrand","loading","error","mutations","SET_BRANDS","SET_SELECTED_BRAND","brand","SET_LOADING","SET_ERROR","isValid","token","currentTime","Date","now","console","log","exp","actions","fetchBrands","commit","rootState","header","Authorization","configuration","headers","response","get","data","message","fetchBrand","text","selectBrands","createBrand","dispatch","post","updateBrand","put","enabledBrand","id","disabledBrand","getters","namespaced"],"sources":["C:/Users/Sergio/Desktop/SOFINV/FrontEnd/src/store/modules/brand.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst state = {\r\n  brands: [],\r\n  selectedBrand: null,\r\n  loading: false,\r\n  error: null,\r\n};\r\n\r\nconst mutations = {\r\n  SET_BRANDS(state, brands) {\r\n    state.brands = brands;\r\n  },\r\n  SET_SELECTED_BRAND(state, brand) {\r\n    state.selectedBrand = brand;\r\n  },\r\n  SET_LOADING(state, loading) {\r\n    state.loading = loading;\r\n  },\r\n  SET_ERROR(state, error) {\r\n    state.error = error;\r\n  },\r\n};\r\n\r\nconst isValid = (token) => {\r\n  const currentTime = Date.now() / 1000;\r\n  console.log(token.exp);\r\n  return token.exp < currentTime;\r\n};\r\n\r\nconst actions = {\r\n  async fetchBrands({ commit, rootState }) {\r\n    commit('SET_LOADING', true);\r\n    try {\r\n      const token = rootState.token; \r\n      console.log(rootState.token);\r\n      if(!isValid(rootState.token)){\r\n        let header = { Authorization: \"Bearer \" + token };\r\n        let configuration = { headers: header };\r\n        const response = await axios.get('api/Brands/ReadBrands', configuration);\r\n        commit('SET_BRANDS', response.data);\r\n      }\r\n    } catch (error) {\r\n      commit('SET_ERROR', error.message);\r\n    } finally {\r\n      commit('SET_LOADING', false);\r\n    }\r\n  },\r\n  async fetchBrand({ commit, rootState  }, text) {\r\n    commit('SET_LOADING', true);\r\n    try {\r\n      const token = rootState.token; \r\n      let header = { Authorization: \"Bearer \" + token };\r\n      let configuration = { headers: header };\r\n      const response = await axios.get(`api/Brands/SearchBrand/${text}`, configuration);\r\n      commit('SET_BRANDS', response.data);\r\n    } catch (error) {\r\n      commit('SET_ERROR', error.message);\r\n    } finally {\r\n      commit('SET_LOADING', false);\r\n    }\r\n  },\r\n  async selectBrands({ commit, rootState }) {\r\n    commit('SET_LOADING', true);\r\n    try {\r\n      const token = rootState.token; \r\n      let header = { Authorization: \"Bearer \" + token };\r\n      let configuration = { headers: header };\r\n      const response = await axios.get('api/Brands/SelectBrands', configuration);\r\n      commit('SET_BRANDS', response.data);\r\n    } catch (error) {\r\n      commit('SET_ERROR', error.message);\r\n    } finally {\r\n      commit('SET_LOADING', false);\r\n    }\r\n  },\r\n  async createBrand({ dispatch, rootState }, brand) {\r\n    const token = rootState.token; \r\n    let header = { Authorization: \"Bearer \" + token };\r\n    let configuration = { headers: header };\r\n    await axios.post('api/Brands/CreateBrand', brand, configuration);\r\n    dispatch('fetchBrands');\r\n  },\r\n  async updateBrand({ dispatch, rootState }, brand) {\r\n    const token = rootState.token; \r\n    let header = { Authorization: \"Bearer \" + token };\r\n    let configuration = { headers: header };\r\n    await axios.put('api/Brands/UpdateBrand', brand, configuration);\r\n    dispatch('fetchBrands');\r\n  },\r\n  async enabledBrand({ dispatch, rootState }, id) {\r\n    const token = rootState.token; \r\n    let header = { Authorization: \"Bearer \" + token };\r\n    let configuration = { headers: header };\r\n    await axios.put(`api/Brands/EnabledBrand/${id}`, {}, configuration);\r\n    dispatch('fetchBrands');\r\n  },\r\n  async disabledBrand({ dispatch, rootState }, id) {\r\n    const token = rootState.token; \r\n    let header = { Authorization: \"Bearer \" + token };\r\n    let configuration = { headers: header };\r\n    await axios.put(`api/Brands/DisabledBrand/${id}`, {}, configuration);\r\n    dispatch('fetchBrands');\r\n  },\r\n};\r\n\r\nconst getters = {\r\n  brands: (state) => state.brands,\r\n  selectedBrand: (state) => state.selectedBrand,\r\n  loading: (state) => state.loading,\r\n  error: (state) => state.error,\r\n};\r\n\r\nexport default {\r\n  namespaced: true,\r\n  state,\r\n  mutations,\r\n  actions,\r\n  getters,\r\n};\r\n\r\n\r\n/* State:\r\nbrands: Un array que contiene todas las marcas obtenidas de la API.\r\nselectedBrand: Un objeto que representa la marca actualmente seleccionada para edición.\r\nloading: Un booleano que indica si se está cargando información (por ejemplo, al hacer una solicitud a la API).\r\nerror: Un string que almacena cualquier mensaje de error que pueda ocurrir durante las operaciones.\r\n\r\nMutations:\r\nSET_BRANDS(state, brands): Actualiza el estado de brands con la lista de marcas obtenidas.\r\nSET_SELECTED_BRAND(state, brand): Establece la marca seleccionada en el estado.\r\nSET_LOADING(state, loading): Actualiza el estado de loading para indicar si se está realizando una operación de carga.\r\nSET_ERROR(state, error): Establece un mensaje de error en el estado.\r\n\r\nActions:\r\nfetchBrands({ commit }): Realiza una solicitud a la API para obtener todas las marcas. Utiliza commit para llamar a las mutaciones correspondientes para actualizar el estado.\r\ncreateBrand({ dispatch }, brand): Envía una solicitud a la API para crear una nueva marca y luego vuelve a obtener la lista de marcas.\r\nupdateBrand({ dispatch }, brand): Envía una solicitud a la API para actualizar una marca existente y luego vuelve a obtener la lista de marcas.\r\ndeleteBrand({ dispatch }, id): Envía una solicitud a la API para eliminar una marca y luego vuelve a obtener la lista de marcas.\r\n\r\nGetters:\r\nbrands: Devuelve la lista de marcas del estado.\r\nselectedBrand: Devuelve la marca seleccionada del estado.\r\nloading: Devuelve el estado de carga.\r\nerror: Devuelve cualquier mensaje de error.\r\n\r\nExport:\r\nnamespaced: true: Esto permite que el módulo sea utilizado de manera independiente, lo que significa que puedes acceder a sus propiedades y métodos utilizando el nombre del módulo (por ejemplo, store.modules.brand.fetchBrands).\r\nSe exporta el objeto que contiene state, mutations, actions y getters. */"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}