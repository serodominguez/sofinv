{"ast":null,"code":"const state = {\n  brands: [],\n  selectedBrand: null,\n  loading: false,\n  error: null,\n  tokenExpiration: null\n};\nconst mutations = {\n  SET_BRANDS(state, brands) {\n    state.brands = brands;\n  },\n  SET_SELECTED_BRAND(state, brand) {\n    state.selectedBrand = brand;\n  },\n  SET_LOADING(state, loading) {\n    state.loading = loading;\n  },\n  SET_ERROR(state, error) {\n    state.error = error;\n  },\n  SET_TOKEN_EXPIRATION(state, expiration) {\n    state.tokenExpiration = expiration;\n  }\n};\n\n// Función auxiliar para validar el token\nconst isTokenValid = tokenExpiration => {\n  if (!tokenExpiration) return false;\n  return new Date() < new Date(tokenExpiration);\n};\nconst actions = {\n  async fetchBrands({\n    commit,\n    rootState\n  }) {\n    if (!isTokenValid(rootState.tokenExpiration)) {\n      commit('SET_ERROR', 'Token no válido o expirado');\n      return;\n    }\n    commit('SET_LOADING', true);\n    try {\n      const token = rootState.token;\n      let header = {\n        Authorization: \"Bearer \" + token\n      };\n      let configuration = {\n        headers: header\n      };\n      const response = await axios.get('api/Brands/ReadBrands', configuration);\n      commit('SET_BRANDS', response.data);\n    } catch (error) {\n      commit('SET_ERROR', error.message);\n    } finally {\n      commit('SET_LOADING', false);\n    }\n  },\n  async fetchBrand({\n    commit,\n    rootState\n  }, text) {\n    if (!isTokenValid(rootState.tokenExpiration)) {\n      commit('SET_ERROR', 'Token no válido o expirado');\n      return;\n    }\n    commit('SET_LOADING', true);\n    try {\n      const token = rootState.token;\n      let header = {\n        Authorization: \"Bearer \" + token\n      };\n      let configuration = {\n        headers: header\n      };\n      const response = await axios.get(`api/Brands/SearchBrand/${text}`, configuration);\n      commit('SET_BRANDS', response.data);\n    } catch (error) {\n      commit('SET_ERROR', error.message);\n    } finally {\n      commit('SET_LOADING', false);\n    }\n  },\n  async selectBrands({\n    commit,\n    rootState\n  }) {\n    if (!isTokenValid(rootState.tokenExpiration)) {\n      commit('SET_ERROR', 'Token no válido o expirado');\n      return;\n    }\n    commit('SET_LOADING', true);\n    try {\n      const token = rootState.token;\n      let header = {\n        Authorization: \"Bearer \" + token\n      };\n      let configuration = {\n        headers: header\n      };\n      const response = await axios.get('api/Brands/SelectBrands', configuration);\n      commit('SET_BRANDS', response.data);\n    } catch (error) {\n      commit('SET_ERROR', error.message);\n    } finally {\n      commit('SET_LOADING', false);\n    }\n  },\n  setToken({\n    commit\n  }, {\n    token,\n    expiration\n  }) {\n    commit('SET_TOKEN_EXPIRATION', expiration);\n    // Aquí también puedes almacenar el token en el estado si es necesario\n  }\n\n  // Resto de las acciones...\n};\nconst getters = {\n  brands: state => state.brands,\n  selectedBrand: state => state.selectedBrand,\n  loading: state => state.loading,\n  error: state => state.error\n};\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions,\n  getters\n};","map":{"version":3,"names":["state","brands","selectedBrand","loading","error","tokenExpiration","mutations","SET_BRANDS","SET_SELECTED_BRAND","brand","SET_LOADING","SET_ERROR","SET_TOKEN_EXPIRATION","expiration","isTokenValid","Date","actions","fetchBrands","commit","rootState","token","header","Authorization","configuration","headers","response","axios","get","data","message","fetchBrand","text","selectBrands","setToken","getters","namespaced"],"sources":["C:/Users/Sergio/Desktop/SOFINV/FrontEnd/src/store/modules/brand.js"],"sourcesContent":["const state = {\r\n  brands: [],\r\n  selectedBrand: null,\r\n  loading: false,\r\n  error: null,\r\n  tokenExpiration: null,\r\n};\r\n\r\nconst mutations = {\r\n  SET_BRANDS(state, brands) {\r\n    state.brands = brands;\r\n  },\r\n  SET_SELECTED_BRAND(state, brand) {\r\n    state.selectedBrand = brand;\r\n  },\r\n  SET_LOADING(state, loading) {\r\n    state.loading = loading;\r\n  },\r\n  SET_ERROR(state, error) {\r\n    state.error = error;\r\n  },\r\n  SET_TOKEN_EXPIRATION(state, expiration) {\r\n    state.tokenExpiration = expiration;\r\n  },\r\n};\r\n\r\n// Función auxiliar para validar el token\r\nconst isTokenValid = (tokenExpiration) => {\r\n  if (!tokenExpiration) return false;\r\n  return new Date() < new Date(tokenExpiration);\r\n};\r\n\r\nconst actions = {\r\n  async fetchBrands({ commit, rootState }) {\r\n    if (!isTokenValid(rootState.tokenExpiration)) {\r\n      commit('SET_ERROR', 'Token no válido o expirado');\r\n      return;\r\n    }\r\n    commit('SET_LOADING', true);\r\n    try {\r\n      const token = rootState.token; \r\n      let header = { Authorization: \"Bearer \" + token };\r\n      let configuration = { headers: header };\r\n      const response = await axios.get('api/Brands/ReadBrands', configuration);\r\n      commit('SET_BRANDS', response.data);\r\n    } catch (error) {\r\n      commit('SET_ERROR', error.message);\r\n    } finally {\r\n      commit('SET_LOADING', false);\r\n    }\r\n  },\r\n\r\n  async fetchBrand({ commit, rootState }, text) {\r\n    if (!isTokenValid(rootState.tokenExpiration)) {\r\n      commit('SET_ERROR', 'Token no válido o expirado');\r\n      return;\r\n    }\r\n    commit('SET_LOADING', true);\r\n    try {\r\n      const token = rootState.token; \r\n      let header = { Authorization: \"Bearer \" + token };\r\n      let configuration = { headers: header };\r\n      const response = await axios.get(`api/Brands/SearchBrand/${text}`, configuration);\r\n      commit('SET_BRANDS', response.data);\r\n    } catch (error) {\r\n      commit('SET_ERROR', error.message);\r\n    } finally {\r\n      commit('SET_LOADING', false);\r\n    }\r\n  },\r\n\r\n  async selectBrands({ commit, rootState }) {\r\n    if (!isTokenValid(rootState.tokenExpiration)) {\r\n      commit('SET_ERROR', 'Token no válido o expirado');\r\n      return;\r\n    }\r\n    commit('SET_LOADING', true);\r\n    try {\r\n      const token = rootState.token; \r\n      let header = { Authorization: \"Bearer \" + token };\r\n      let configuration = { headers: header };\r\n      const response = await axios.get('api/Brands/SelectBrands', configuration);\r\n      commit('SET_BRANDS', response.data);\r\n    } catch (error) {\r\n      commit('SET_ERROR', error.message);\r\n    } finally {\r\n      commit('SET_LOADING', false);\r\n    }\r\n  },\r\n\r\n  setToken({ commit }, { token, expiration }) {\r\n    commit('SET_TOKEN_EXPIRATION', expiration);\r\n    // Aquí también puedes almacenar el token en el estado si es necesario\r\n  },\r\n\r\n  // Resto de las acciones...\r\n};\r\n\r\nconst getters = {\r\n  brands: (state) => state.brands,\r\n  selectedBrand: (state) => state.selectedBrand,\r\n  loading: (state) => state.loading,\r\n  error: (state) => state.error,\r\n};\r\n\r\nexport default {\r\n  namespaced: true,\r\n  state,\r\n  mutations,\r\n  actions,\r\n  getters,\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}